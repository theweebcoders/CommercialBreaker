• **Orchestrator Pattern**  
  – Use the `LogicController` in `API/FrontEndLogic.py` as the single source of truth for state and actions. :contentReference[oaicite:1]{index=1}  
  – Never bypass `LogicController`—all new features must integrate through a method in `FrontEndLogic.py` that spawns a background thread and broadcasts status updates.

• **Project Structure & Imports**  
  – Keep modules in their proper folders:  
    • Core logic under `ComBreak/` or `ToonamiTools/`  
    • UI code under `GUI/` or `CLI/`  
    • Orchestration under `API/FrontEndLogic.py` and `API/components/`.  
  – When creating new modules, update the `__init__.py` in that folder to export classes.  
  – Import only what you need—no unused imports or circular references.  
  – Use absolute imports for cross-module references: `from API import LogicController`  
  – Use relative imports within the same package: `from .components import MessageBroker`  
  – Import `ToonamiTools` at module level, not inside functions

• **Threading & Status Broadcasting**  
  – Any long-running operation must run inside a thread started by `threading.Thread(...)`.  
  – Use `self._broadcast_status_update("message")` before, during, and after the operation to keep UIs in sync.  
  – Do not perform UI updates or direct print statements inside threads—always communicate via the message broker.

• **Data Broadcasting via Message Broker**  
  – For non-status data (lists, objects, etc.), use dedicated channels:  
    • Serialize data to JSON: `json.dumps(data)`  
    • Publish to specific channel: `self._publish_status_update('channel_name', json_data)`  
    • Example channels: `'plex_servers'`, `'plex_libraries'`, `'filtered_files'`, `'cutless_state'`  
  – UIs must deserialize: `data = json.loads(received_data)`  
  – Always publish data updates after status updates for consistency.

• **Error Handling Conventions**  
  – Wrap risky code in `try/except` blocks.  
  – On a known exception, broadcast `“Known error occurred: {error}”`.  
  – On an unexpected exception, broadcast `“Unexpected error: {error}”` and re-raise for debugging.  
  – Never let exceptions silently pass without broadcasting.

• **Naming & Style**  
  – Follow **PEP8** for Python naming: `snake_case` for functions and variables, `PascalCase` for classes.  
  – Use **type hints** wherever practical.  
  – Document every new class and complex function with a Google-style docstring.  

• **Formatting & Linters**  
  – Run **Black** on all Python files before committing.  
  – Ensure code passes `flake8` with no errors.  
  – No trailing whitespace or unused variables—Copilot should not generate dead code.

• **Dependency & Packaging**  
  – Use the minimal `setup.py` boilerplate (as in your workflow) to allow pip installs.  
  – Any new third-party library must be added to `requirements/pre_deps.txt`, `requirements/runtime.txt`, or `requirements/graphics.txt` as appropriate.  
  – Do not modify `setup.py` by hand if it’s autogenerated during build—update `requirements/` files instead.

• **Module Development**  
  – When adding a new ToonamiTools or ComBreak component, mirror existing patterns:  
    • Create a class with an `__init__(...)` that accepts config/parameters.  
    • Implement appropriate methods (e.g., `run()`, `process()`, specific operations).  
    • Provide a `cleanup()` if any resources (files, DB connections) need closing.  
  – Integrate new components by invoking them inside a `LogicController` thread and broadcasting status updates before and after.

• **Database & File Operations**  
  – Use `with sqlite3.connect(...) as conn:` for any DB access to ensure automatic commit/rollback.  
  – Process large files in small chunks (e.g., 8KB reads) to avoid high memory usage.  
  – Temporary files or fixtures must be cleaned up in `finally:` blocks or via context managers.

• **Configuration Management**  
  – Always import configuration from `config.py`  
  – Never hardcode paths, URLs, or credentials  
  – Use config constants: `config.DATABASE_PATH`, `config.WORKING_DIR`, etc.  
  – Access stored values via `self._get_data(key)` and `self._set_data(key, value)`

• **Testing Conventions (S.A.R.A.)**  
  – Place all tests under the `tests/` directory using **pytest**.  
  – Use zero-byte fixtures defined in `tests/fixtures/sample.txt` and let `conftest.py` build them.  
  – Every new feature must include at least one corresponding test.  
  – Ensure test names start with `test_` and use descriptive assertions:  
    ```python
    def test_my_feature_behaves_correctly(tmp_path):
        # Setup using sample.txt structure
        assert wait_for_status("Expected Status", "FeatureName", timeout=30)
    ```
  – **REQUIRED**: Run `pytest tests/test_sara_automatic.py` locally and ensure all tests pass before creating any PR.  
  – Run `pytest -v -s` locally to validate before pushing—Copilot will do the same when opening a PR.

• **UI Integration**  
  – All UI pages or CLI commands must subscribe to status updates from `LogicController` (e.g., `self.logic.subscribe_to_status_updates(self.update_status)`).  
  – All UI pages must subscribe to updates from `LogicController`:  
    • Status updates: `self.logic.subscribe_to_status_updates(self.update_status)`  
    • Data updates: `self.logic.subscribe_to_updates('channel_name', self.handler)`  
    • Handle JSON deserialization in data handlers:  
      ```python
      def handle_plex_servers_update(self, data):
          server_list = json.loads(data) if isinstance(data, str) else data
          # Process server_list
      ```  
  – Never call business-logic methods (like new features) directly—use the orchestrator.  
  – Buttons or commands trigger `logic.some_action()`; do not mix UI logic and core logic.

• **Performance & Resource Management**  
  – For memory-intensive tasks, process files in chunks and release resources in `finally` clauses.  
  – If using threads, avoid shared mutable state—always copy or lock shared data if needed.  
  – Explicitly call `resource.cleanup()` or close DB cursors to prevent leaks.

• **Platform Compatibility & Cutless Mode**  
  – Check `FlagManager.cutless` before deciding between virtual vs. physical processing.  
  – Use `FlagManager` or configuration flags (`self._get_data("platform_type")`) to branch code for DizqueTV vs. Tunarr features.  
  – Raise `ValueError("Unsupported platform: {platform_type}")` if an unknown platform is detected.

• **Contribution Workflow**  
  – Fork, create a feature branch from `main`, implement according to these rules, update documentation (API-Reference.md, Component-Documentation.md), write tests, then open a PR.  
  – **Before creating a PR, you MUST**:
    1. Run `pytest tests/test_sara_automatic.py` and ensure all tests pass
    2. Run `black .` to format your code
    3. Ensure `flake8` passes with no errors
  – PR titles must clearly state “Add/Update <feature>: <short description>”.  
  – In PR description, include:  
    1. What changed  
    2. Why it changed  
    3. How to test  
    4. Any migration notes (e.g., DB schema updates)
    5. Confirmation that S.A.R.A. tests pass: "✅ All tests in test_sara_automatic.py pass"

• **Documentation Updates**  
  – Whenever adding features or changing APIs, update:  
    • `API-Reference.md` for orchestrator methods  
    • `Component-Documentation.md` for new ComBreak/ToonamiTools modules  
    • `User-Guides.md` for UI/CLI changes  
    • `FAQ.md` if there’s a new common question.  
  – Keep all docs in markdown, no HTML or embedded images—plain text only.

• **Advanced Topics**  
  – If creating a new custom UI (e.g., a React frontend), still rely on `LogicController` and message broker for status.  
  – When integrating with external services, wrap API calls in try/except and broadcast errors if unreachable.

• **Logging & Debugging**  
  – Use `print()` sparingly only for developer debugging; always follow with a `_broadcast_status_update()` for user-visible feedback.  
  – If a status never appears in UI, check the message broker subscription patterns first.  
  – All status updates use the `'status_updates'` channel exclusively.  
  – For feature-specific data, use dedicated channels like `'plex_servers'`, `'plex_libraries'`, etc.

• **General Formatting**  
  – No tabs—use 4 spaces per indent.  
  – Wrap lines at 79 characters unless dealing with long URLs or SQL queries.  
  – Comments should be full sentences with capitalization and punctuation.

